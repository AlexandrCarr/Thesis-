import pandas as pd

df = pd.read_excel('/Users/alexandrcarr/Desktop/DIss.xlsx')

df = df.iloc[:1220]

###################
## Data Cleaning ##
###################

# Creating Reference Categories For Dummy Variables
categories_to_drop = {
    'Ethnicity': 'White',
    'Gender': 'Male',
    'Min Education Requirements': 'Primary School',
    'Income-Ethnicity': 'Low White',
    'Qualification': 'Low',
    'Income': 'Low',
    'Region': 'Prague',
    'City': 'Prague'
}

# List of columns to create dummies for
columns_to_dummies = [
    'Qualification', 'Ethnicity', 'Income-Ethnicity', 'Job Category', 'Income',
    'Industry', 'Department', 'Min Education Requirements', 'City', 'Region',
    'Gender', 'Education', 'Pro-Roma'
]

# Dictionary to keep track of all the dropped dummies
all_dropped_dummies = {}

# Create dummy variables for each column in the list
for column in columns_to_dummies:
    # Create the dummy variables without dropping any
    dummies = pd.get_dummies(df[column], prefix=column.replace(' ', '_'), dtype=int)
    
    # Determine which category to drop
    if column in categories_to_drop:
        # If there's a specific category to drop, use it
        category_to_drop = categories_to_drop[column]
    else:
        # Otherwise, drop the first category
        category_to_drop = df[column].sort_values().unique()[0]
    
    # Record the dropped category
    all_dropped_dummies[column] = category_to_drop
    
    # Drop the specified category from the dummies
    category_col = f"{column.replace(' ', '_')}_{category_to_drop}"
    dummies.drop(columns=[category_col], inplace=True)
    
    # Drop the original column from the dataframe to avoid the name conflict when joining
    df = df.drop(columns=[column])
    
    # Rename the dummy columns to have the format 'OriginalName: DummyName'
    new_column_names = {original: f"{column}: {dummy.split('_')[-1]}" for original, dummy in zip(dummies.columns, dummies.columns)}
    dummies.rename(columns=new_column_names, inplace=True)
    
    # Join the dummy variables with the original dataframe
    df = df.join(dummies)

# Merging dummies into categories to ease analysis 

mergers = {
    "Food Production": ["Baking", "Meat", "Groceries", "Meats"],
    "Hotel and Restaurant Services": ["Hotel", "Hotel ", "Restaraunts", "Restaurant"],
    "Heavy Industry Manufacturing": ["Heavy industry", "Heavy industry manufacturing", "Industry", "Inudstrials", "Steel  ", "Steel Trade"],
    "Retail Sales": ["Fashion", "Fast Food", "Furniture"],
    "Luxury Retail Sales": ["Watches", "Luxury"],
    "Healthcare and Pharmaceuticals": ["Pharma", "Pharmaceuticals", "Healthcare", "Medical Devices"],
    "Agriculture": ["Horticulture", "Agriculture"],
    "Financial Services and Investment": ["Finance", "Investment", "Real Estate", "Consulting"],
    "Energy Engineering and Maintenance": ["Renewable energy", "Energy"],
    "TMT": ["Software Engineering", "Technology", "Transportation", "Metereology"],
    "HR and Recruiting": ["HR consulting", "Recruiting", "Staffing and Recruiting"],
    "Advertising and Marketing": ["Advertising", "Marketing"],
    "Public Sector": ["Public Sector - city level", "Public Sector - transport"]
}

# Iterate over each merger and perform the merging
for merged_name, industries in mergers.items():
    # Create a column for the merged industry
    merged_col_name = f"Industry: {merged_name}"
    df[merged_col_name] = 0
    
    for industry in industries:
        original_col_name = f"Industry: {industry}"
        # Update the merged column if any of the industries in the merger has a 1
        df[merged_col_name] = df[merged_col_name] | df[original_col_name]
        # Drop the original column
        df.drop(columns=[original_col_name], inplace=True)

# Print out all the dropped dummies to verify
print("All dropped dummies:")
for column, category in all_dropped_dummies.items():
    print(f"{column}: {category}")
    

###############
## Modelling ##
###############


import statsmodels.api as sm
import os

# Selecting the dependent variable
Y = df['Outcome']

# List of prefixes for your dummy variables
dummy_prefixes = [
    'Gender:',  'Ethnicity:', 'Income-Ethnicity: High Roma', 'Income-Ethnicity: High White',
    'Income-Ethnicity: Low Roma', 'Region:', 'Education:', 'Job Category:', 'Income:', 'Industry:', 
    'Qualification:','Min_Education Requirements:'
]
# Selecting the independent variables (all the dummies for specified columns)
X = df[[col for col in df.columns if any(col.startswith(prefix) for prefix in dummy_prefixes)]]

# Ensure that independent variables are correctly identified
if X.empty:
    raise ValueError("No independent variables were found. Check your dummy variable prefixes.")

# Adding a constant to the model (for intercept)
X = sm.add_constant(X)

# Fit the OLS model
ols_model = sm.OLS(Y, X).fit()

# Fit the Logit model
logit_model = sm.Logit(Y, X).fit()

# Get the summary tables as LaTeX
ols_summary_latex = ols_model.summary().as_latex()
logit_summary_latex = logit_model.summary().as_latex()

# Define a function to save LaTeX content to a file
def save_latex_to_file(latex_content, file_path):
    with open(file_path, 'w') as f:
        f.write(latex_content)

# Save the LaTeX content to files
output_dir = '/Users/alexandrcarr/Desktop/'  
os.makedirs(output_dir, exist_ok=True)

# Save OLS summary to LaTeX file
ols_latex_file_path = os.path.join(output_dir, 'ols_summary.tex')
save_latex_to_file(ols_summary_latex, ols_latex_file_path)

# Save Logit summary to LaTeX file
logit_latex_file_path = os.path.join(output_dir, 'logit_summary.tex')
save_latex_to_file(logit_summary_latex, logit_latex_file_path)

# Print the file paths for the user
print(f"OLS summary saved to: {ols_latex_file_path}")
print(f"Logit summary saved to: {logit_latex_file_path}")
